# Async homework

в этом задании требуется написать аналог unix pipeline, что-то вроде:

```bash
cat common.go | grep func | sort | uniq -c | sort -n  
```

когда STDOUT одной программы передается как STDIN в другую программу

но в данном случае эти роли выполняют каналы, которые передаются из одной функции в другую.

само задание по сути состоит из двух частей

* написание функции `RunPipeline` которая обеспечивает нам конвейерную обработку функций-воркеров, которые что-то делают.
* написание нескольких функций, которые считают нам информацию по письмам пользователей

если кратко, то необходимо запустить следующую цепочку:

```bash
cat emails.txt | SelectUsers | SelectMessages | CheckSpam | CombineResults
```

то есть мы получаем на вход имейлы юзеров, селектим их из "базы" и получаем каждому юзеру user_id. затем селектим по каждому user_id список писем(msg_id) этого юзера. дальше проверяем эти письма на спам и выдаем итоговый результат: какие у письма со спамом, а какие нет.

а теперь подробнее про реализацию этой цепочки:

* `SelectUsers()`
  * `in` - `string` внутри `interface{}`. это имейлы юзеров
  * `out` - отдает структурки `User{}`. это результат функции `GetUser()`
  * особенности:
    * `GetUser()` выполняется 1 секунду. его можно вызывать параллельно для нескольких юзеров. это экономит время
    * у некоторых юзеров есть alias'ы(псевдонимы). то есть на вид это два разных имейла, но на самом деле это один и тот же юзер в базе. например "batman@mail.ru" - это алиас к "bruce.wayne@mail.ru". `SelectUsers()` должен отдавать в `out` только уникальных юзеров.
* `SelectMessages()`
  * `in` -  `User{}` внутри `interface{}` от `SelectUsers()`
  * `out` - отдает `MsgID`. это айдишники писем юзеров - результат функции `GetMessages()`
  * особенности:
    * `GetMessages()` выполняется 1 секунду. его тоже можно вызывать параллельно.
    * но `GetMessages()` позволяет использовать "батчи". то есть за раз в нее можно запихнуть не 1 юзера, а несколько. максимальное кол-во юзеров = 2. то есть если мы хотим селектнуть у 10ти юзеров письма, то это можно сделать за 5 вызовов `GetMessages()`. в тестах проверяется, что кол-во вызовов оптимальное
* `CheckSpam()`
  * `in` - `MsgID` внутри `interface{}`. это айдишники писем
  * `out` - `MsgData{}`. это структура с парой полей: id и факт того является ли письмо спамом. это результат работы `HasSpam()`
  * особенности:
    * `HasSpam()` симулирует поход в сервис антиспама, чтоб проверить письмо на наличие спама. один запрос выполняется за 100мс. и у этого сервиса есть "антибрут" - его нельзя вызывать бесконтрольно в кучу потоков. если сделать к нему более 5 параллельных запросов, то он начнет возвращать ошибку и данные о наличии спама вы не получите.
* `CombineResults()`
  * `in` - `MsgData` внутри `interface{}`
  * `out` - `string`. это строки вида "<has_spam> <msg_id>", например "true 17696166526272393238"
  * особенности:
    * `CombineResults()` ждет все результаты из `in`, а потом сортирует их по наличию спама и по msg_id. то есть пример вывода может быть такой:

            true 123
            true 5555
            true 5556
            false 140
            false 3000
            false 3005


Код писать в spammer.go.
Запускать как `go test -v -race`